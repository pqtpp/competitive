"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * DAG representing dependencies.
 * For example, this mapping means item1 depends on item2 and item3.
 * { item1: Set(item2, item3) }
 */
var DAG = /** @class */ (function () {
    function DAG() {
        var _this = this;
        this.map = new Map();
        this.addNode = function (node) {
            _this.ensureNode(node);
        };
        this.addEdge = function (from, to) {
            _this.ensureNode(to);
            var dependencies = _this.ensureNode(from);
            dependencies.add(to);
            var cycle = _this.detectCyclicDependency(from);
            if (typeof cycle !== 'undefined') {
                throw new Error("cyclic dependency detected: " + cycle.join(' -> '));
            }
        };
        /**
         * Returns Ts for each depdnent level from less dependents to more dependents.
         * i.g.)
         * - A1 depends on B
         * - A2 depends on B
         * - B depends on C1
         * - B depends on C2
         * => [
         *   [A1, A2],
         *   [B],
         *   [C1, C2]
         * ]
         */
        this.dependenciesForEachDepth = function () {
            var go = function (dependencies, result) {
                var independentKeys = Array.from(dependencies)
                    .filter(function (_a) {
                    var set = _a[1];
                    return set.size === 0;
                })
                    .map(function (_a) {
                    var key = _a[0];
                    return key;
                });
                independentKeys.forEach(function (independentKey) {
                    dependencies.delete(independentKey);
                    Array.from(dependencies).forEach(function (_a) {
                        var set = _a[1];
                        return set.delete(independentKey);
                    });
                });
                var next = __spreadArrays([independentKeys], result);
                return dependencies.size === 0 ? next : go(dependencies, next);
            };
            var clone = Array.from(_this.map).reduce(function (acc, _a) {
                var key = _a[0], dependencies = _a[1];
                return acc.set(key, new Set(dependencies));
            }, new Map());
            return go(clone, []);
        };
        this.ensureNode = function (node) {
            var set = _this.map.get(node) || new Set();
            _this.map.set(node, set);
            return set;
        };
        this.detectCyclicDependency = function (from) {
            var go = function (current, dependencies) {
                if (dependencies.length === 0) {
                    return;
                }
                return Array.from(current)
                    .map(function (node) {
                    var ds = __spreadArrays(dependencies, [node]);
                    var cycleDetected = node === from;
                    return cycleDetected ? ds : go(_this.map.get(node) || new Set(), ds);
                })
                    .find(function (res) { return typeof res !== 'undefined'; });
            };
            return go(_this.map.get(from) || new Set(), [from]);
        };
    }
    return DAG;
}());
exports.DAG = DAG;
