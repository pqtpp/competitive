export interface Resource<T, D> {
    resolve: Resolve<T, D>;
    finalize: (item: T) => Promise<void>;
}
export interface Definition {
    [key: string]: {
        dependencies: {
            [key: string]: any;
        };
        value: any;
    };
}
export declare type Injector<T extends {
    [key: string]: any;
}> = {
    [P in keyof T]: Promise<T[P]>;
};
export declare type Resolve<V, D> = (injector: Injector<D>) => Promise<V>;
export declare type PromisesHandler = (ps: Promise<void>[]) => Promise<void>;
declare type Resolvable<V, D> = (injector: Injector<D>) => V | Promise<V>;
declare type ExactOneValue<T> = {
    [P in keyof T]: Exclude<T[keyof T], T[P]> extends never ? T[P] : never;
}[keyof T];
declare type DependentValue<T extends Definition, K> = ExactOneValue<{
    [P in keyof T]: K extends keyof T[P]['dependencies'] ? T[P]['dependencies'][K] : never;
}>;
declare type BoundKeys<T extends Definition> = Extract<{
    [P in keyof T]: keyof T[P]['dependencies'];
}[keyof T], keyof T>;
declare type MissingKeys<T extends Definition> = Exclude<{
    [P in keyof T]: keyof T[P]['dependencies'];
}[keyof T], keyof T>;
declare type MissingDependencies<T extends Definition> = {
    [P in MissingKeys<T>]: DependentValue<T, P>;
};
declare type ConflictedKeys<T extends Definition> = {
    [P in BoundKeys<T>]: T[P]['value'] extends DependentValue<T, P> ? never : P;
}[BoundKeys<T>];
declare type Requirements<T extends Definition> = MissingDependencies<T> & {
    [P in ConflictedKeys<T>]: never;
};
export interface Result<T extends Definition> {
    container: Container<T>;
    finalize: (promisesHandler?: PromisesHandler) => Promise<void>;
}
export declare type Container<T extends Definition> = {
    [P in keyof T]: T[P]['value'];
};
export declare type Underlying<T extends Definition> = {
    [P in keyof T]: Resource<T[P]['value'], T[P]['dependencies']>;
};
/**
 * Design represents key-value styled dependency graph which can detect which dependent key is missing at compile time.
 *
 * i.g.)
 * ```
 * type HasNumber = { numberKey: number }
 *
 * // NOTE: `(injector: Injector<T>) => Promise<U>` represents dependencies for a value U.
 * // Injector<T> resolves value T[keyof T] by calling `injector.key()` asynchronously.
 * const detectStringFromNumber =
 *   async (injector: Injector<HasNumber>) => `number is ${await injector.numberKey}`;
 *
 * const design = Design.empty
 *   .bind('stringFromNumber', detectStringFromNumber);
 *
 * design.resolve({}) // compile error
 * design.resolve({ numberKey: 123 }) // returns Promise({ numberKey: 123, stringFromNumber: 'number is 123' })
 * ```
 *
 * see specs for more examples!
 *
 */
export declare class Design<T extends Definition> {
    readonly design: Underlying<T>;
    private constructor();
    bind: <K extends string, V, D = {}>(key: K, resolvable: Resolvable<V, Container<T> & D>, finalize?: (item: V) => Promise<void>) => Design<T & { [key in K]: {
        dependencies: D;
        value: V;
    }; }>;
    merge: <U extends Definition>(that: Design<U>) => Design<T & U>;
    resolve: (requirements: Requirements<T>) => Promise<Result<T>>;
    static pure: <U extends {
        [key: string]: any;
    }>(mapping: U) => Design<{ [P in keyof U]: {
        dependencies: {};
        value: U[P];
    }; }>;
    static empty: Design<{}>;
    static bind: <K extends string, V, D = {}>(key: K, resolvable: Resolvable<V, Container<{}> & D>, finalize?: (item: V) => Promise<void>) => Design<{ [key in K]: {
        dependencies: D;
        value: V;
    }; }>;
}
export {};
